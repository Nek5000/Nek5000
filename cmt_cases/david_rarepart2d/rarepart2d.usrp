c----------------------------------------------------------------------
      subroutine stokes_particles
      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'
      include 'mpif.h'
c   This routine has 3 parts:
c
c   O init_stokes_particles 
c
c         o Initialize number of particles on each processor.
c
c         o They can all start on rank 0, if desired and if there is
c           sufficient memory.
c
c   O update_stokes_particles
c
c         o Particles are moved, subject to Stokes drag, using a
c           stable semi-implict BDFk/EXTk timestepper.  For timestep i,
c           k=min(i,3).
c
c         o If memory permits, particles will migrate to the processor 
c           holding their element and stay there till they move to another
c           processor.
c
c         o If memory does not permit, particles will stay where they
c           are, but will move back and forth for interpolation.
c           Thus, the particle update will correctly proceed but will
c           incur extra communication overhead.
c
c         o If starting with n particles on each processor, it is reasonable
c           to set lpart=2*n, so one may hold as many as 2n particles on any
c           given processor.
c
c   O output_stokes_particles
c
c         o At the moment, this is a really stupid hack.  Output requirements
c           differ by orders of magnitude from one application to the next, so
c           we do not yet have a determined output format.  This is more or less
c           left to the user.
c
c         o Any serious particle tracking will want the output in binary, using
c           parallel I/O.
c
c         o Currently, there is no restart capability, but it would be simple
c           enough to dump ipart() and rpart() arrays for each processor in 
c           order to checkpoint.
c
c   O Data:
c
c         There are two arrays, ipart(li,lpart) and rpart(li,lpart)
c
c         o ipart(*,i) holds vital pointer information for the ith particle 
c                      on the current node.  
c
c              - It is easy to add auxiliary pointers (tags), such as
c                the step number in which the particle was added to the
c                list, the particle id (local or global, but less than 
c                1 billion), etc.
c
c              - To adduxiliary integer data, just increase the parameter li
c                and start to fill in the integer locations in the range
c
c                ipart(jai:ni,i)  i=1,2,...,n
c
c                jai is the pointer to auxiliary integers
c
c         o rpart(*,i) holds real values associated with advancement of the
c                      ith particle on the current node.  
c
c              - Values stored here include saved values of position and
c                velocity used in BDFk/EXTk, the Stokes number, etc.
c
c              - You can also store different times at which the particle positions
c                are updated in order to support variable timestepping.
c
c         o Both arrays are exchanged via the crystal router tuple call.
c     parameter (lr=14*ldim+8,li=5+1)
      parameter (lr=14*3+8,li=5+1)
      common  /cpartr/ rpart(lr,lpart) ! Minimal value of lr = 14*ndim+1
      common  /cparti/ ipart(li,lpart) ! Minimal value of li = 5
      common  /iparti/ n,nr,ni
      integer nw,ierr

      real    pt_timers(11), scrt_timers(11)
      common /trackingtime/ pt_timers, scrt_timers

      if (istep.eq.0) then
         nr = lr     ! Mandatory for proper striding
         ni = li     ! Mandatory

         call rzero(rpart,lr*lpart)
         call izero(ipart,li*lpart)
         scrt_timers(2) = dnekclock()
         call baryweights
         call init_stokes_particles   (rpart,nr,ipart,ni,n) ! n initialized here
         pt_timers(2) = pt_timers(2) + dnekclock() - scrt_timers(2)
      else
         scrt_timers(3) = dnekclock()
         call update_stokes_particles (rpart,nr,ipart,ni,n)
         pt_timers(3) = pt_timers(3) + dnekclock() - scrt_timers(3)
      endif

c     output particles
      if(mod(istep,iostep).eq.0.or.istep.eq.1) then
         call output_particles_newest    (rpart,nr,ipart,ni,n,istep)
c        call output_particles_new       (rpart,nr,ipart,ni,n) ! serial
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine init_stokes_particles(rpart,nr,ipart,ni,n)
      include 'SIZE'
      include 'TOTAL'

      real    rpart(nr,n)
      integer ipart(ni,n)
      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff

      integer nw
      real    rho_p, dp, tau_p,mu_0

      call set_part_pointers

      llpart = lpart
      k  = 0 
c     l  = 0 
c     nid_last = 0

      rho_p     = 8050       ! kg/m^3, example particle density (steel)
      tau_p     = 0.01        ! s, particle time scale (stokes number)
      mu_0      = 18.27E-6   ! Pa s, inital fluid viscosity
      dp        = sqrt(18.0*tau_p*mu_0/rho_p)  

      nw = 16  
      if (mod(nw,np) .ne. 0) then
         if (nid.eq.0) then 
         write(6,*)'***Make num. of particles divisible by num. procs)'
         call exitt
         endif
      endif

c     xstart = -1.9
c     ystart =  0.05
c     zstart =  0.0         ! not used in 2d simulation
c     xlen   =  2.3
c     ylen   =  1.15
c     zlen   =  0.0       ! not used in 2d simulation
      xstart = -0.1
      ystart =  0.05
      zstart =  1.0         ! not used in 2d simulation
      xlen   =  0.0
      ylen   =  1.15
      zlen   =  0.0       ! not used in 2d simulation
c     dum = ran2(-2) ! use this setting for verification
      dum = rand(-1)

c        do l = 1,nw/np
c           dumx = ran2(2)
c           dumy = ran2(2)
c           dumz = ran2(2)

c           ls = l + nid*nw/np 
c           if (l.gt.llpart)then 
c              write(6,*)'Not enough space to store more particles'
c              call exitt
c           endif
c           rpart(jx ,l)   = xstart + dumx*xlen
c           rpart(jy ,l)   = ystart + dumy*ylen
c           rpart(jz ,ls)   = zstart + dumz*zlen
c           rpart(jf0,l)   = 0.0        ! this is the body force
c           rpart(jtaup,l) = tau_p      ! particle time scale
c           rpart(jdp,l)   = dp         ! particle diameter

c           ipart(jai,ls)   = ls          ! partid 
c        enddo
c           print *, 'nid,ls,l', nid, ls, l


      do i = 1,nw 
         dumx = ran2(2)
         dumy = ran2(2)
         dumz = ran2(2)
         if (mod(k,np).eq.nid) then ! particle _only_ on this processor
            l=l+1  ! local count
            if (l.gt.llpart)then 
               write(6,*)'Not enough space to store more particles'
               call exitt
            endif
            rpart(jx ,l)   = xstart + dumx*xlen
            rpart(jy ,l)   = ystart + dumy*ylen
            rpart(jz ,l)   = zstart + dumz*zlen
            rpart(jf0,l)   = 0.0        ! this is the body force
            rpart(jtaup,l) = tau_p      ! particle time scale
            rpart(jdp,l)   = dp         ! particle diameter

            ipart(jai,l)   = i          ! partid 
         endif

         k = k+1     ! Total count
      enddo
      lcount = nw/np
      npart=0
      npart  = max(npart,lcount)
      n = npart
      call interp_u_for_adv(rpart,nr,ipart,ni,n,vx,vy,vz)
      return
      end
c-----------------------------------------------------------------------
      subroutine set_part_pointers
      include 'SIZE'
c     Minimal value of ni = 5
c     Minimal value of nr = 14*ndim + 1
      common  /iparti/ n,nr,ni
      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff
      jrc = 1 ! Pointer to findpts return code
      jpt = 2 ! Pointer to findpts return processor id
      je0 = 3 ! Pointer to findpts return element id
      jps = 4 ! Pointer to proc id for data swap
      jai = 5 ! Pointer to auxiliary integers
      nai = ni - (jai-1)  ! Number of auxiliary integers
      if (nai.le.0) call exitti('Error in nai:$',ni)

c     jr  = 1         ! Pointer to findpts return rst variables
c     jd  = jr + ndim ! Pointer to findpts return distance
c     jx  = jd + 1    ! Pointer to findpts input x value
c     jy  = jx + 1    ! Pointer to findpts input y value
c     jz  = jy + 1    ! Pointer to findpts input z value

c     jx1 = jx + ndim ! Pointer to xyz at t^{n-1}
c     jx2 = jx1+ ndim ! Pointer to xyz at t^{n-1}
c     jx3 = jx2+ ndim ! Pointer to xyz at t^{n-1}

c     jv0 = jx3+ ndim ! Pointer to current particle velocity
c     jv1 = jv0+ ndim ! Pointer to particle velocity at t^{n-1}
c     jv2 = jv1+ ndim ! Pointer to particle velocity at t^{n-2}
c     jv3 = jv2+ ndim ! Pointer to particle velocity at t^{n-3}

c     ju0 = jv3+ ndim ! Pointer to current fluid velocity
c     ju1 = ju0+ ndim ! Pointer to fluid velocity at t^{n-1}
c     ju2 = ju1+ ndim ! Pointer to fluid velocity at t^{n-2}
c     ju3 = ju2+ ndim ! Pointer to fluid velocity at t^{n-3}

c     jf0 = ju3+ ndim ! Pointer to forcing at current timestep



      jr  = 1         ! Pointer to findpts return rst variables
      jd  = jr + 3 ! Pointer to findpts return distance
      jx  = jd + 1    ! Pointer to findpts input x value
      jy  = jx + 1    ! Pointer to findpts input y value
      jz  = jy + 1    ! Pointer to findpts input z value

      jx1 = jx + 3 ! Pointer to xyz at t^{n-1}
      jx2 = jx1+ 3 ! Pointer to xyz at t^{n-1}
      jx3 = jx2+ 3 ! Pointer to xyz at t^{n-1}

      jv0 = jx3+ 3 ! Pointer to current particle velocity
      jv1 = jv0+ 3 ! Pointer to particle velocity at t^{n-1}
      jv2 = jv1+ 3 ! Pointer to particle velocity at t^{n-2}
      jv3 = jv2+ 3 ! Pointer to particle velocity at t^{n-3}

      ju0 = jv3+ 3 ! Pointer to current fluid velocity
      ju1 = ju0+ 3 ! Pointer to fluid velocity at t^{n-1}
      ju2 = ju1+ 3 ! Pointer to fluid velocity at t^{n-2}
      ju3 = ju2+ 3 ! Pointer to fluid velocity at t^{n-3}

      jf0 = ju3+ 3 ! Pointer to forcing at current timestep

c     particle force specific parameteres
      jtaup    = jf0+   1 ! particle time scale for standards stokes d
      jtemp    = jtaup+ 1 ! temperature at particle location
      jrho     = jtemp+ 1 ! density at particle location
      ja       = jrho+  1 ! speed of sound at particle location
      jdp      = ja+    1 ! particle diameter
      jstcoeff = jdp+   1 ! particle diameter

      jar = jstcoeff+1 ! Pointer to auxiliary reals
      nar = nr - (jar-1)  ! Number of auxiliary reals

      if (nar.le.0) call exitti('Error in nar:$',nr)
      return
      end
c----------------------------------------------------------------------
      subroutine interp_u_for_adv(rpart,nr,ipart,ni,n,ux,uy,uz)
c     Interpolate fluid velocity at current xyz points and move
c     data to the processor that owns the points.
c     Input:    n = number of points on this processor
c     Output:   n = number of points on this processor after the move
c     Code checks for n > lpart and will not move data if there
c     is insufficient room.
      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal
      common /myparth/ i_fp_hndl, i_cr_hndl

      real    pt_timers(11), scrt_timers(11)
      common /trackingtime/ pt_timers, scrt_timers

      real    rpart(nr,n),ux(1),uy(1),uz(1)
      integer ipart(ni,n)

      parameter (lrf=4+ldim,lif=5+1)
      real               rfpts(lrf,lpart)
      common /fptspartr/ rfpts
      integer            ifpts(lif,lpart),fptsmap(lpart)
      common /fptsparti/ ifpts,fptsmap

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff
      integer icalld1
      save    icalld1
      data    icalld1 /0/

      logical partl         ! This is a dummy placeholder, used in cr()
      nl = 0                ! No logicals exchanged

      scrt_timers(4) = dnekclock()
      if (icalld1.eq.0) then
         tolin = 1.e-12
         if (wdsize.eq.4) tolin = 1.e-6
         call intpts_setup  (tolin,i_fp_hndl)
         call crystal_setup (i_cr_hndl,nekcomm,np)
         icalld1 = icalld1 + 1
      endif

      scrt_timers(9) = dnekclock()
      call particles_in_nid(fptsmap,rfpts,lrf,ifpts,lif,nfpts,rpart,nr
     $                     ,ipart,ni,n)

      scrt_timers(5) = dnekclock()
      call findpts(i_fp_hndl !  stride     !   call findpts( ihndl,
     $           , ifpts(jrc,1),lif        !   $             rcode,1,
     $           , ifpts(jpt,1),lif        !   &             proc,1,
     $           , ifpts(je0,1),lif        !   &             elid,1,
     $           , rfpts(jr ,1),lrf        !   &             rst,ndim,
     $           , rfpts(jd ,1),lrf        !   &             dist,1,
     $           , rfpts(jx ,1),lrf        !   &             pts(    1),1,
     $           , rfpts(jy ,1),lrf        !   &             pts(  n+1),1,
     $           , rfpts(jz ,1),lrf ,nfpts)    !   &             pts(2*n+1),1,n)
      scrt_timers(5) = dnekclock() - scrt_timers(5)
      pt_timers(5) = scrt_timers(5) + pt_timers(5)

      nmax = iglmax(n,1)
      if (nmax.gt.lpart) then
         if (nid.eq.0) write(6,1) nmax,lpart
    1    format('WARNING: Max number of particles:'
     $   i9,'.  Not moving because lpart =',i9,'.')
      else
         scrt_timers(6) = dnekclock()
c        copy rfpts and ifpts back into their repsected positions in rpart and ipart
         call update_findpts_info(rpart,nr,ipart,ni,n,rfpts,lrf
     $                       ,ifpts,lif,fptsmap,nfpts)
         scrt_timers(9) = dnekclock() - scrt_timers(9) - scrt_timers(5)
         pt_timers(9) = scrt_timers(9) + pt_timers(9)
c        Move particle info to the processor that owns each particle
c        using crystal router in log P time:

         jps = jai-1     ! Pointer to temporary proc id for swapping
         do i=1,n        ! Can't use jpt because it messes up particle info
            ipart(jps,i) = ipart(jpt,i)
         enddo
         call crystal_tuple_transfer(i_cr_hndl,n,lpart
     $              , ipart,ni,partl,nl,rpart,nr,jps)
c        Sort by element number - for improved local-eval performance
         call crystal_tuple_sort    (i_cr_hndl,n 
     $              , ipart,ni,partl,nl,rpart,nr,je0,1)
         pt_timers(6) = pt_timers(6) + dnekclock() - scrt_timers(6)
      endif

c     Interpolate (locally, if data is resident).
      scrt_timers(7) = dnekclock()
      call baryweights_findpts_eval(rpart,nr,ipart,ni,n)
      pt_timers(7) = pt_timers(7) + dnekclock() - scrt_timers(7)
      pt_timers(4) = pt_timers(4) + dnekclock() - scrt_timers(4)
      return
      end
c-----------------------------------------------------------------------
      subroutine update_stokes_particles(rpart,nr,ipart,ni,n)
c     Single step of Stokes particle dynamics
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CTIMER'

      common /myparth/ i_fp_hndl, i_cr_hndl
      common /myparts/ times(0:3),alpha(0:3),beta(0:3)
      real    pt_timers(11), scrt_timers(11)
      common /trackingtime/ pt_timers, scrt_timers

      real    rpart(nr,n)
      integer ipart(ni,n)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff
      jx0 = jx

      scrt_timers(8) = dnekclock()
      call get_bdf_ext_coefs(beta,alpha,times)
c     Solve for velocity at time t^n
      do j=0,ndim-1
      do i=1,n
         rpart(ju3+j,i)=rpart(ju2+j,i)
         rpart(ju2+j,i)=rpart(ju1+j,i)
         rpart(ju1+j,i)=rpart(ju0+j,i)
         rpart(jv3+j,i)=rpart(jv2+j,i)
         rpart(jv2+j,i)=rpart(jv1+j,i)
         rpart(jv1+j,i)=rpart(jv0+j,i)
         rpart(jx3+j,i)=rpart(jx2+j,i)
         rpart(jx2+j,i)=rpart(jx1+j,i)
         rpart(jx1+j,i)=rpart(jx0+j,i)
      enddo
      enddo
      
      call qs_force_corrections(rpart,nr,ipart,ni,n) ! qs force correc.

      do i=1,n
c       s = 1.0 / rpart(jtaup,i)    ! coeff in front of (u-v), no corr
        s = rpart(jstcoeff,i)       ! coeff in front of (u-v), w/ corr
        do j=0,ndim-1
          rhs = s*( alpha(1)*rpart(ju1+j,i)
     $            + alpha(2)*rpart(ju2+j,i)
     $            + alpha(3)*rpart(ju3+j,i)) + rpart(jf0,i)
     $        +     beta (1)*rpart(jv1+j,i)
     $        +     beta (2)*rpart(jv2+j,i)
     $        +     beta (3)*rpart(jv3+j,i)
          rpart(jv0+j,i) = rhs / (beta(0)+s) ! Implicit solve for v
          rhx = beta (1)*rpart(jx1+j,i)
     $        + beta (2)*rpart(jx2+j,i)
     $        + beta (3)*rpart(jx3+j,i) + rpart(jv0+j,i)
          rpart(jx0+j,i) = rhx / beta(0)     ! Implicit solve for x
        enddo
      enddo
c     check if all particles are inside the domain:
      call update_particle_location(nr,n,jx0,jx1,jx2,jx3,rpart)
      pt_timers(8) = pt_timers(8) + dnekclock() - scrt_timers(8)

c     Interpolate current velocity field at current position, to
c     be used in _next_ particle update step.
      call compute_primitive_vars
      call interp_u_for_adv(rpart,nr,ipart,ni,n,vx,vy,vz)
      return
      end
c-----------------------------------------------------------------------
      subroutine qs_force_corrections(rpart,nr,ipart,ni,n)
c
      include 'SIZE'
      include 'TOTAL'
      real    rpart(nr,n)
      integer ipart(ni,n)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff

      real mu_0,c0,T0
     >     ,Re_p,mu_p,M_p,M_cr,vel_diff
     >     ,cd, cd_cr, cd_m1, cd_m175,cd_std
     >     ,csup(3),fsup(3),xi_sup
     >     ,csub(3),fsub(3),xi_sub
     >     ,rep,mag_sq

      csup(1) = 6.48
      csup(2) = 8.93
      csup(3) = 12.21

      csub(1) = csup(1)
      csub(2) = 9.28
      csub(3) = csub(3)

      M_cr = 0.6         ! critical mach number for sphere

c     Sutherlands law for air (moderate), viscosity at particles location
      c0   = 120         ! K
      T0   = 291.15      ! K
      mu_0 = 18.27E-6    ! Pa s, inital fluid viscosity (need to change!)

      do i=1,n
c        sutherlands law (air)
         if (istep.eq.0) then
            mu_p = mu_0*(T0 + c0)/(rpart(jtemp,i) + c0)*
     >             (rpart(jtemp,i)/T0)**1.5
         else
             mu_p = mu_0
         endif
         
         mag_sq = (rpart(ju0,i)   - rpart(jv0,i))**2 +
     >            (rpart(ju0+1,i) - rpart(jv0+1,i))**2
         vel_diff = sqrt(mag_sq)

         Re_p = rpart(jrho,i)*rpart(jdp,i)*vel_diff/mu_p
         M_p  = vel_diff/rpart(ja,i)


            cd_cr   = (24.0/Re_p)*(1 + 0.15*Re_p**0.684) +
     >               0.513*(1.0 + 483.0*Re_p**-0.669)**-1
            cd_std  = (24.0/Re_p)*(1 + 0.15*Re_p**0.687) +
     >               0.420*(1.0 + 42500.0*Re_p**-1.16)**-1
            cd_m1   = (24.0/Re_p)*(1 + 0.118*Re_p**0.813) +
     >               0.690*(1.0 + 3550.0*Re_p**-0.793)**-1
            cd_m175 = (24.0/Re_p)*(1 + 0.107*Re_p**0.867) +
     >               0.646*(1.0 + 861.0*Re_p**-0.634)**-1

            fsup(1) = -2.963 + 4.392*M_p - 1.169*M_p*M_p
     >                -0.027*M_p*M_p*M_p - 0.233*exp((1-M_p)/0.011)
            fsup(2) = -6.617 + 12.11*M_p - 6.501*M_p*M_p
     >                +1.182*M_p*M_p*M_p - 0.174*exp((1-M_p)/0.010)
            fsup(3) = -5.866 + 11.57*M_p - 6.665*M_p*M_p
     >                +1.312*M_p*M_p*M_p - 0.350*exp((1-M_p)/0.012)

            fsub(1) = -1.884 + 8.422*M_p - 13.70*M_p*M_p
     >                +8.162*M_p*M_p*M_p 
            fsub(2) = -2.228 + 10.35*M_p - 16.96*M_p*M_p
     >                +9.840*M_p*M_p*M_p 
            fsub(3) = 4.362 - 16.91*M_p + 19.84*M_p*M_p
     >                -6.296*M_p*M_p*M_p 


c        set appropriate drag coeffecient
         if (Re_p .le. 1E-16) then ! Re << 1
c           print *, 'Re << 1'
            cd = 0.0
            rpart(jstcoeff,i) = 1.0/rpart(jtaup,i)
            cycle
         else                     ! Finite Re
c           below critical mach number, but still finite
            if (M_p .le. M_cr) then
c               print *, 'M < 0.6'
                
                cd = cd_std + (cd_cr - cd_std)*M_p/M_cr
            elseif ((M_p .gt. M_cr) .and. (M_p .le. 1)) then
c           intermediate mach number 
c               print *, '0.6 < M < 1'
                xi_sub = 0.0
                do j=1,3
                do k=1,3
                   rep = 1.0
                if (k.ne.j) then
                   rep = rep*(log(Re_p) - csub(k))/(csub(j) - csub(k))
                endif
                enddo 
                   xi_sub = xi_sub + fsub(k)*rep
                enddo 

                cd = cd_cr + (cd_m1 - cd_cr)*xi_sub 
            else 
c           > 1 mach number, still need to code > 1.75
c               print *, 'M > 1'
                xi_sup = 0.0
                do j=1,3
                do k=1,3
                   rep = 1.0
                if (k.ne.j) then
                   rep = rep*(log(Re_p) - csup(k))/(csup(j) - csup(k))
                endif
                enddo 
                   xi_sup = xi_sup + fsup(k)*rep
                enddo 

                cd = cd_m1 + (cd_m175 - cd_m1)*xi_sup 
            endif
         endif

         rpart(jar,i) = cd
         
c        if (ipart(jai,i) .eq. 2) then
c           print *, 'Re, M, cd', Re_p, M_p, cd
c        endif

         rpart(jstcoeff,i) = Re_p*cd/24.0/rpart(jtaup,i)
      enddo
      end
c-----------------------------------------------------------------------
      subroutine get_bdf_ext_coefs(beta,alpha,times)
      include 'SIZE'
      include 'TOTAL'

      real beta(0:3),alpha(0:3),times(0:3)
      real c(0:8)

      integer ilast,ncoef
      save    ilast,ncoef
      data    ilast,ncoef / -9 , 0 /

      do i=3,1,-1
         times(i)=times(i-1)
      enddo
      times(0) = time

      call rzero(beta ,4)
      call rzero(alpha,4)
      if (istep.ne.ilast) then
         ilast = istep
         ncoef = ncoef + 1
         ncoef = min(ncoef,3) ! Maximum 3rd order in time
      endif
      ncoefm1 = ncoef - 1

      call fd_weights_full(times(0),times(1),ncoefm1,0,alpha(1))
      call fd_weights_full(times(0),times(0),ncoef,1,c)
      do j=0,ncoef
         beta(j) = c(ncoef+1+j)
      enddo
      do j=1,ncoef
         beta(j) = -beta(j)  ! Change sign, for convenience
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine update_particle_location(nr,n,jx0,jx1,jx2,jx3,rpart)
      include 'SIZE'

      real rpart(nr,n)
      real  xdrange(2,3) 
      common /domainrange/ xdrange

      do i=1,n
         do j=0,ndim-1
            if (rpart(jx0+j,i).lt.xdrange(1,j+1))then
               rpart(jx0+j,i) = xdrange(2,j+1) - 
     &                          abs(xdrange(1,j+1) - rpart(jx0+j,i))
               rpart(jx1+j,i) = xdrange(2,j+1) + 
     &                          abs(xdrange(1,j+1) - rpart(jx1+j,i))
               rpart(jx2+j,i) = xdrange(2,j+1) + 
     &                          abs(xdrange(1,j+1) - rpart(jx2+j,i))
               rpart(jx3+j,i) = xdrange(2,j+1) + 
     &                          abs(xdrange(1,j+1) - rpart(jx3+j,i))
            endif
            if (rpart(jx0+j,i).gt.xdrange(2,j+1))then
               rpart(jx0+j,i) = xdrange(1,j+1) +
     &                          abs(rpart(jx0+j,i) - xdrange(2,j+1))
               rpart(jx1+j,i) = xdrange(1,j+1) -
     &                          abs(xdrange(2,j+1) - rpart(jx1+j,i))
               rpart(jx2+j,i) = xdrange(1,j+1) -
     &                          abs(xdrange(2,j+1) - rpart(jx2+j,i))
               rpart(jx3+j,i) = xdrange(1,j+1) -
     &                          abs(xdrange(2,j+1) - rpart(jx3+j,i))
            endif
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine output_particles_newest(rpart,nr,ipart,ni,n,istep)
      include 'SIZE'
      include 'mpif.h'

      common /nekmpi/ mid,np,nekcomm,nekgroup,nekreal

      real    rpart(nr,n)
      integer ipart(ni,n)

      real x(ldim,lpart),partv(lpart)
      common /scrns/ x_tmp(ldim+2,lpart),work(ldim+2,lpart)
     $              ,v_tmp(ldim+1,lpart)
      character*128 fname
      character*15 mystring
      integer oldfile, wdata_type, newfile
      integer*8 disp
      integer*8 extent_in_file, lb,extent
      integer stride_len , block_len
      integer prevs(0:np-1)
      logical ifexist
      integer status_mpi(MPI_STATUS_SIZE)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff
      integer icalld
      save    icalld
      data    icalld  /-1/

c     sned previous number of particles before a given mpi rank
c     so that propper striding can be done
      call MPI_Send(n, 1, MPI_INTEGER, 0, 0, nekcomm, ierr)

      stride_len = 0
      npt_total = iglsum(n,1)

c     write particle data to read into script
      if (nid.eq. 0) then
         prevs(0) = n
         do i=1,np-1
            call MPI_Recv(prevs(i),1,MPI_INTEGER,i,
     >                    0,nekcomm,status_mpi,ierr)
         enddo
      endif

      call MPI_BCAST(prevs,np, MPI_INTEGER,0,nekcomm,ierr) 

c     striding depends on the number of particles per mpi rank on
c     all of the previous mpi ranks from [0, nid-1]
      if (nid .ne. 0) then
      do i=1,nid
         stride_len = stride_len + prevs(i-1)
      enddo
      endif


c     write to file
      icalld = icalld+1
      write(mystring,'(A7,I5.5,A3)') 'partxyz', icalld, '.3D' 
      
      call MPI_FILE_OPEN(nekcomm, mystring,
     >                   MPI_MODE_CREATE + MPI_MODE_WRONLY, 
     >                   MPI_INFO_NULL, oldfile, ierr) 
c     disp = 0
c     call MPI_FILE_SET_VIEW(oldfile, disp, MPI_BYTE,
c    >                       MPI_BYTE, "native", 
c    >                       MPI_INFO_NULL, ierr) 

      if (n .gt. 0) then
          block_len=1
      else
          block_len=0
      endif
      call MPI_Type_vector(n,block_len,nr,MPI_DOUBLE_PRECISION,
     >                    wdata_type,ierr)
      call MPI_Type_commit(wdata_type,ierr)

c     write x particle location
      disp = 8*stride_len 
c     disp = 0 
      call MPI_FILE_SET_VIEW(oldfile, disp, MPI_DOUBLE_PRECISION,
     >                       MPI_DOUBLE_PRECISION, "native", 
     >                       MPI_INFO_NULL, ierr) 
      call MPI_FILE_WRITE(oldfile, rpart(jx,1), block_len,
     >                  wdata_type,
     >                  MPI_STATUS_IGNORE, ierr) 

c     write y particle location
      disp = 8*stride_len + 8*npt_total
      call MPI_FILE_SET_VIEW(oldfile, disp, MPI_DOUBLE_PRECISION,
     >                       MPI_DOUBLE_PRECISION, "native", 
     >                       MPI_INFO_NULL, ierr) 
      call MPI_FILE_WRITE(oldfile, rpart(jy,1), block_len,
     >                  wdata_type,
     >                  MPI_STATUS_IGNORE, ierr) 

c     close file
      call MPI_FILE_CLOSE(oldfile, ierr) 


c     write properties of one particle i.e. particle id number 2
      do i=1,n
         if (ipart(jai,i) .eq. 2) then
               open(74,file='velhistory',position='append',
     >              action='write')
            write(74, "(I6,F9.5,F9.5,F9.5)") istep
     >          ,rpart(jx,i)
     >          ,rpart(ju0,i)
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine particles_in_nid(fptsmap,rfpts,nrf,ifpts,nif,nfpts
     &                            ,rpart,nr,ipart,ni,n)
      include 'SIZE'

      real    rpart(nr,n)
      integer ipart(ni,n)

      real    rfpts(nrf,*)
      integer ifpts(nif,*),fptsmap(*)

      real   xerange(2,3,lelt)
      common /elementrange/ xerange

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff

      nfpts = 0
      do ip = 1,n
         xloc = rpart(jx,ip)
         yloc = rpart(jy,ip)
         zloc = rpart(jz,ip)
         itest = 0
         do ie=1,nelt
            if (xloc.ge.xerange(1,1,ie).and.xloc.le.xerange(2,1,ie))then
            if (yloc.ge.xerange(1,2,ie).and.yloc.le.xerange(2,2,ie))then
            if (zloc.ge.xerange(1,3,ie).and.zloc.le.xerange(2,3,ie))then
                ipart(je0 ,ip) = ie-1
                ipart(jrc ,ip) = 0
                ipart(jpt ,ip) = nid
                rpart(jd  ,ip) = 1.0 
                rloc = -1.0 + 2.0*(xloc - xerange(1,1,ie))/
     $                 (xerange(2,1,ie)-xerange(1,1,ie))
                sloc = -1.0 + 2.0*(yloc - xerange(1,2,ie))/
     $                 (xerange(2,2,ie)-xerange(1,2,ie))
                tloc = -1.0 + 2.0*(zloc - xerange(1,3,ie))/
     $                 (xerange(2,3,ie)-xerange(1,3,ie))
                rpart(jr  ,ip) = rloc
                rpart(jr+1,ip) = sloc
                rpart(jr+2,ip) = tloc
                itest = 1
                goto 123
            endif
            endif
            endif
         enddo
         if (itest.eq.0)then
            nfpts = nfpts + 1
            fptsmap(nfpts) = ip
            call copy (rfpts(1,nfpts),rpart(1,ip),nrf) 
            call icopy(ifpts(1,nfpts),ipart(1,ip),nif) 
            if(nfpts.gt.lpart)then
               write(6,*)'Too many points crossing over ',
     $                      nfpts,lpart,nid
               call exitt
            endif
         endif
123      continue
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine update_findpts_info(rpart,nr,ipart,ni,n,rfpts,nrf
     $                         ,ifpts,nif,fptsmap,nfpts)
      include 'SIZE'
      real    rpart(nr,n)
      integer ipart(ni,n)

      real    rfpts(nrf,nfpts)
      integer ifpts(nif,nfpts),fptsmap(nfpts)
      do ifp = 1,nfpts
         call copy(rpart(1,fptsmap(ifp)),rfpts(1,ifp),nrf)
         call icopy(ipart(1,fptsmap(ifp)),ifpts(1,ifp),nif)
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine baryweights
      include 'SIZE' 
      include 'INPUT' 
c
c     calculates the barycentric lagrange weights
c
      common /BARYPARAMS/ xgll, ygll, zgll, wxgll, wygll, wzgll
      real xgll(lx1), ygll(ly1), zgll(lz1),
     >     wxgll(lx1), wygll(ly1), wzgll(lz1)


      one = 1.0
      pi  = 4.0*atan(one)

c     get gll points in all directions
      call zwgll(xgll,wxgll,lx1)
      call zwgll(ygll,wygll,ly1)
      call rone(zgll,lz1)
      if(if3d) call zwgll(zgll,wzgll,lz1)
c     set all weights to ones first
      call rone(wxgll,lx1)
      call rone(wygll,ly1)
      call rone(wzgll,lz1)
c     calc x bary weights
      do j=1,lx1
         do k=1,lx1
            if (j .NE. k) then
               wxgll(j) = wxgll(j)/(xgll(j) - xgll(k))
            endif
         enddo
      enddo
c     calc y bary weights
      do j=1,ly1
         do k=1,ly1
            if (j .NE. k) then
               wygll(j) = wygll(j)/(ygll(j) - ygll(k))
            endif
         enddo
      enddo
c     calc z bary weights
      do j=1,lz1
         do k=1,lz1
            if (j .NE. k) then
               wzgll(j) = wzgll(j)/(zgll(j) - zgll(k))
            endif
         enddo
      enddo
      return 
      end
c-----------------------------------------------------------------------
      subroutine baryweights_findpts_eval(rpart,nr,ipart,ni,n)
      include 'SIZE'
      include 'INPUT'
      include 'SOLN'
      include 'CMTDATA'
      real    rpart(nr,n)
      integer ipart(ni,n)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff

      common /BARRYREP/ rep, bot
      real              rep(lx1,ly1,lz1), bot
      nxyz = nx1*ny1*nz1
      if (if3d) then
        do i=1,n
           call init_baryinterp(rpart(jr,i),rpart(jr+1,i),rpart(jr+2,i))
           ie  =  ipart(je0,i) + 1
           call baryinterp_new(vx(1,1,1,ie),rpart(ju0,i))
           call baryinterp_new(vy(1,1,1,ie),rpart(ju0+1,i))
           call baryinterp_new(vz(1,1,1,ie),rpart(ju0+2,i))
        enddo
      else
        do i=1,n
           ie  =  ipart(je0,i) + 1
           call baryinterp(rpart(jr,i),rpart(jr+1,i),vx(1,1,1,ie),
     >                     rpart(ju0,i))   ! x velocity interpolation
           call baryinterp(rpart(jr,i),rpart(jr+1,i),vy(1,1,1,ie),
     >                     rpart(ju0+1,i)) ! y velocity interpolation
           call baryinterp(rpart(jr,i),rpart(jr+1,i),t(1,1,1,ie,1),
     >                     rpart(jtemp,i)) ! temperature interpolation
           call baryinterp(rpart(jr,i),rpart(jr+1,i),vtrans(1,1,1,ie,1),
     >                     rpart(jrho,i))  ! density interpolation
           call baryinterp(rpart(jr,i),rpart(jr+1,i),csound(1,1,1,ie),
     >                     rpart(ja,i))    ! sound speed interpolation
        enddo
      endif
      return
      end
c-----------------------------------------------------------------------
      subroutine init_baryinterp(x,y,z)
      include 'SIZE'
      common /BARYPARAMS/ xgll, ygll, zgll, wxgll, wygll, wzgll
      real xgll(lx1), ygll(ly1), zgll(lz1),
     >     wxgll(lx1), wygll(ly1), wzgll(lz1)
      common /BARRYREP/ rep, bot
      real              rep(lx1,ly1,lz1), bot

      real x, y, z, repy, repz,repx
      real bwgtx(lx1),bwgty(ly1),bwgtz(lz1)
c     main loop, but notice bwgtz, bwgtx, bwgty could be NaN if
c     interpolated point is on a grid location. Need to fix, but
c     is currently very robust
      bot= 0.00
      do k=1,nz1
         bwgtz(k) = wzgll(k)/(z-zgll(k))
      enddo
      do i=1,nx1
         bwgtx(i) = wxgll(i)/(x-xgll(i))
      enddo 
      do j=1,ny1
         bwgty(j) = wygll(j)/(y-ygll(j))
      enddo
      do k=1,nz1
      do j=1,ny1
         repdum = bwgty(j)*bwgtz(k)
      do i=1,nx1
         rep(i,j,k) =  repdum* bwgtx(i)
         bot        =  bot + rep(i,j,k)
      enddo
      enddo
      enddo 
      return
      end
c-----------------------------------------------------------------------
      subroutine baryinterp_new(field,pofx)
      include 'SIZE'

      common /BARRYREP/ rep, bot
      real              rep(lx1,ly1,lz1), bot
      real field(1),pofx,top

      top = 0.00
      nxyz = nx1*ny1*nz1
      do i=1,nxyz
         top =  top + rep(i,1,1)*field(i)
      enddo
      pofx = top/bot
      return
      end
c-----------------------------------------------------------------------
      FUNCTION ran2(idum)
      INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV 
      REAL ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     $        IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,
     $        IR2=3791,NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
c Long period (> 2 ! 1018 ) random number generator of Lâ€™Ecuyer with 
c Bays-Durham shuffle and added safeguards. Returns a uniform random deviate 
c between 0.0 and 1.0 (exclusive of the endpoint values). 
c Call with idum a negative integer to initialize; thereafter, do not alter 
c idum between successive deviates in a sequence. RNMX should approximate the 
c largest floating value that is less than 1.
      INTEGER idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/, iv/NTAB*0/, iy/0/
      if (idum.le.0) then 
         idum1=max(-idum,1) 
         idum2=idum1
         do j=NTAB+8,1,-1
            k=idum1/IQ1
            idum1=IA1*(idum1-k*IQ1)-k*IR1 
            if (idum1.lt.0) idum1=idum1+IM1 
            if (j.le.NTAB) iv(j)=idum1
         enddo
         iy=iv(1) 
      endif
      k=idum1/IQ1 
      idum1=IA1*(idum1-k*IQ1)-k*IR1
      if (idum1.lt.0) idum1=idum1+IM1 
      k=idum2/IQ2 
      idum2=IA2*(idum2-k*IQ2)-k*IR2 
      if (idum2.lt.0) idum2=idum2+IM2 
      j=1+iy/NDIV
      iy=iv(j)-idum2
      iv(j)=idum1 
      if(iy.lt.1)iy=iy+IMM1 
      ran2=min(AM*iy,RNMX)
      return
      END
c-----------------------------------------------------------------------
c     subtroutines not currently used, but useful for instruction
c----------------------------------------------------------------------
      subroutine output_particles_new(rpart,nr,ipart,ni,n)
      include 'SIZE'

      real    rpart(nr,n)
      integer ipart(ni,n)

      real x(ldim,lpart),partv(lpart)
      common /scrns/ x_tmp(ldim+2,lpart),work(ldim+2,lpart)
     $              ,v_tmp(ldim+1,lpart)
      character*128 fname

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup,jtemp,jrho,ja,jdp,jstcoeff
      integer icalld
      save    icalld
      data    icalld  /-1/

      icalld = icalld+1
      if (nid.eq.0) then
        write(fname,1) icalld
 1      format('part',i5.5,'.3D')
        open(unit=72,file=fname)

        write(fname,2) icalld
 2      format('vel',i5.5,'.3D')
        open(unit=73,file=fname)
      endif

      npt_total = iglsum(n,1)
      npass = npt_total / lpart
      if (npt_total.gt.npass*lpart) npass = npass+1
      ilast = 0
      do ipass=1,npass
        mpart = min(lpart,npt_total-ilast)
        i0    = ilast
        i1    = i0 + mpart
        ilast = i1

        call rzero(x_tmp,(ldim+2)*lpart)
        call rzero(v_tmp,(ldim+1)*lpart)
        do ii=1,n ! loop over all particles
          if (i0.lt.ipart(jai,ii).and.ipart(jai,ii).le.i1) then
            i = ipart(jai,ii)-i0
            call copy(x_tmp(1,i),rpart(jx,ii),ldim)  ! Coordinates
            x_tmp(ldim+1,i) = ipart(jpt,ii) ! MPI rank
            x_tmp(ldim+2,i) = ipart(jai,ii) ! Part id 
            call copy(v_tmp(1,i),rpart(jv0,ii),ldim)  ! Velocity 
            v_tmp(ldim+1,i) = ipart(jai,ii) ! Part id 
          endif
        enddo
        call gop(x_tmp,work,'+  ',(ldim+2)*lpart)
        call gop(v_tmp,work,'+  ',(ldim+1)*lpart)
        if (nio.eq.0) write(72,3)((x_tmp(k,i),k=1,ldim+2),i=1,mpart)
        if (nio.eq.0) write(73,4)((v_tmp(k,i),k=1,ldim+1),i=1,mpart)
 3      format(1p5e17.9)
 4      format(1p4e17.9)
      enddo

      if (nio.eq.0) close(72)
      if (nio.eq.0) close(73)
      return
      end
c-----------------------------------------------------------------------
      subroutine baryinterp(x,y,fields,p)
c
c     not currently used, but here for illustration; replaced by
c     baryinterp_new and init_baryinterp
c
      include 'SIZE'
      
      common /BARYPARAMS/ xgll, ygll, zgll, wxgll, wygll, wzgll
      real xgll(lx1), ygll(ly1), zgll(lz1),
     >     wxgll(lx1), wygll(ly1), wzgll(lz1)
      real      top, bot, p
      real x, y, repx, repy, xdiff, ydiff
      real fields(lx1,ly1)

      top = 0.0
      bot = 0.0
c     main loop, but notice repx, repy, repz could be NaN if
c     interpolated point is on a grid location. Need to fix, but
c     is currently very robust
      do j=1,ly1
         ydiff = y - ygll(j)
         repy = wygll(j)/ydiff
         do i=1,lx1
            xdiff = x - xgll(i)
            repx = repy*wxgll(i)/xdiff
            top = top + repx*fields(i,j)
            bot = bot + repx
         enddo
      enddo

      p = top/bot
      return 
      end
c----------------------------------------------------------------------

c----------------------------------------------------------------------
      subroutine stokes_particles
      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'
      include 'mpif.h'
c   This routine has 3 parts:
c
c   O init_stokes_particles 
c
c         o Initialize number of particles on each processor.
c
c         o They can all start on rank 0, if desired and if there is
c           sufficient memory.
c
c   O update_stokes_particles
c
c         o Particles are moved, subject to Stokes drag, using a
c           stable semi-implict BDFk/EXTk timestepper.  For timestep i,
c           k=min(i,3).
c
c         o If memory permits, particles will migrate to the processor 
c           holding their element and stay there till they move to another
c           processor.
c
c         o If memory does not permit, particles will stay where they
c           are, but will move back and forth for interpolation.
c           Thus, the particle update will correctly proceed but will
c           incur extra communication overhead.
c
c         o If starting with n particles on each processor, it is reasonable
c           to set lpart=2*n, so one may hold as many as 2n particles on any
c           given processor.
c
c   O output_stokes_particles
c
c         o At the moment, this is a really stupid hack.  Output requirements
c           differ by orders of magnitude from one application to the next, so
c           we do not yet have a determined output format.  This is more or less
c           left to the user.
c
c         o Any serious particle tracking will want the output in binary, using
c           parallel I/O.
c
c         o Currently, there is no restart capability, but it would be simple
c           enough to dump ipart() and rpart() arrays for each processor in 
c           order to checkpoint.
c
c   O Data:
c
c         There are two arrays, ipart(li,lpart) and rpart(li,lpart)
c
c         o ipart(*,i) holds vital pointer information for the ith particle 
c                      on the current node.  
c
c              - It is easy to add auxiliary pointers (tags), such as
c                the step number in which the particle was added to the
c                list, the particle id (local or global, but less than 
c                1 billion), etc.
c
c              - To adduxiliary integer data, just increase the parameter li
c                and start to fill in the integer locations in the range
c
c                ipart(jai:ni,i)  i=1,2,...,n
c
c                jai is the pointer to auxiliary integers
c
c         o rpart(*,i) holds real values associated with advancement of the
c                      ith particle on the current node.  
c
c              - Values stored here include saved values of position and
c                velocity used in BDFk/EXTk, the Stokes number, etc.
c
c              - You can also store different times at which the particle positions
c                are updated in order to support variable timestepping.
c
c         o Both arrays are exchanged via the crystal router tuple call.
      parameter (lr=14*ldim+3,li=5+1)
      common  /cpartr/ rpart(lr,lpart) ! Minimal value of lr = 14*ndim+1
      common  /cparti/ ipart(li,lpart) ! Minimal value of li = 5
      common  /iparti/ n,nr,ni
      integer nw,ierr

      real    pt_timers(11), scrt_timers(11)
      common /trackingtime/ pt_timers, scrt_timers

      if (istep.eq.0) then
         nr = lr     ! Mandatory for proper striding
         ni = li     ! Mandatory

         call rzero(rpart,lr*lpart)
         call izero(ipart,li*lpart)
         scrt_timers(2) = dnekclock()
         call baryweights
         call init_stokes_particles   (rpart,nr,ipart,ni,n) ! n initialized here
         pt_timers(2) = pt_timers(2) + dnekclock() - scrt_timers(2)
      else
         scrt_timers(3) = dnekclock()
         call update_stokes_particles (rpart,nr,ipart,ni,n)
         pt_timers(3) = pt_timers(3) + dnekclock() - scrt_timers(3)
      endif

c     output particles
      if(mod(istep,iostep).eq.0.or.istep.eq.1) then
c        serial
c        scrt_timers(10) = dnekclock()
c        call output_particles_new       (rpart,nr,ipart,ni,n)
c        pt_timers(10) = dnekclock() - scrt_timers(10)
c        call MPI_Barrier(MPI_COMM_WORLD,ierr)

c        parallel
c        scrt_timers(11) = dnekclock()
         call output_particles_newest    (rpart,nr,ipart,ni,n,istep)
c        pt_timers(11) = dnekclock() - scrt_timers(11)
c        call MPI_Barrier(MPI_COMM_WORLD,ierr)

         ptdum = glsum(pt_timers(10),1)
         if(nid.eq.0) print *, 'serial io            ', ptdum
     &                        , ptdum/np
         ptdum = glsum(pt_timers(11),1)
         if(nid.eq.0) print *, 'mpi    io            ', ptdum
     &                        , ptdum/np
      endif
      return
      end
c----------------------------------------------------------------------
      subroutine init_stokes_particles(rpart,nr,ipart,ni,n)
      include 'SIZE'
      include 'TOTAL'

      real    rpart(nr,n)
      integer ipart(ni,n)
      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup

      integer nw

      call set_part_pointers

      llpart = lpart
      k  = 0 
      l  = 0 

      nw = 128   
      xstart = -0.900
      ystart = -0.900
      zstart = -0.9000
      xlen   = 1.800
      ylen   = 1.800
      zlen   = 1.800
c     dum = ran2(-2) ! use this setting for verification
      dum = rand(-1)
      do i = 1,nw 
         dumx = ran2(2)
         dumy = ran2(2)
         dumz = ran2(2)
         if (mod(k,np).eq.nid) then ! particle _only_ on this processor
            l=l+1  ! local count
            if (l.gt.llpart)then 
               write(6,*)'Not enough space to store more particles'
               call exitt
            endif
            rpart(jx ,l)   = xstart + dumx*xlen
            rpart(jy ,l)   = ystart + dumy*ylen
            rpart(jz ,l)   = zstart + dumz*zlen
            rpart(jf0,l)   = 0.0        ! this is the body force
            rpart(jtaup,l) = 0.5        ! particle time scale
            ipart(jai,l)   = i          ! partid 
         endif
         k = k+1     ! Total count
      enddo
      lcount = l
      npart=0
      npart  = max(npart,lcount)
      n = npart
      call interp_u_for_adv(rpart,nr,ipart,ni,n,vx,vy,vz)
      return
      end
c-----------------------------------------------------------------------
      subroutine set_part_pointers
      include 'SIZE'
c     Minimal value of ni = 5
c     Minimal value of nr = 14*ndim + 1
      common  /iparti/ n,nr,ni
      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup
      jrc = 1 ! Pointer to findpts return code
      jpt = 2 ! Pointer to findpts return processor id
      je0 = 3 ! Pointer to findpts return element id
      jps = 4 ! Pointer to proc id for data swap
      jai = 5 ! Pointer to auxiliary integers
      nai = ni - (jai-1)  ! Number of auxiliary integers
      if (nai.le.0) call exitti('Error in nai:$',ni)

      jr  = 1         ! Pointer to findpts return rst variables
      jd  = jr + ndim ! Pointer to findpts return distance
      jx  = jd + 1    ! Pointer to findpts input x value
      jy  = jx + 1    ! Pointer to findpts input y value
      jz  = jy + 1    ! Pointer to findpts input z value

      jx1 = jx + ndim ! Pointer to xyz at t^{n-1}
      jx2 = jx1+ ndim ! Pointer to xyz at t^{n-1}
      jx3 = jx2+ ndim ! Pointer to xyz at t^{n-1}

      jv0 = jx3+ ndim ! Pointer to current particle velocity
      jv1 = jv0+ ndim ! Pointer to particle velocity at t^{n-1}
      jv2 = jv1+ ndim ! Pointer to particle velocity at t^{n-2}
      jv3 = jv2+ ndim ! Pointer to particle velocity at t^{n-3}

      ju0 = jv3+ ndim ! Pointer to current fluid velocity
      ju1 = ju0+ ndim ! Pointer to fluid velocity at t^{n-1}
      ju2 = ju1+ ndim ! Pointer to fluid velocity at t^{n-2}
      ju3 = ju2+ ndim ! Pointer to fluid velocity at t^{n-3}

      jf0 = ju3+ ndim ! Pointer to forcing at current timestep

      jtaup = jf0+ 1

      jar = jtaup+1 ! Pointer to auxiliary reals
      nar = nr - (jar-1)  ! Number of auxiliary reals

      if (nar.le.0) call exitti('Error in nar:$',nr)
      return
      end
c----------------------------------------------------------------------
      subroutine interp_u_for_adv(rpart,nr,ipart,ni,n,ux,uy,uz)
c     Interpolate fluid velocity at current xyz points and move
c     data to the processor that owns the points.
c     Input:    n = number of points on this processor
c     Output:   n = number of points on this processor after the move
c     Code checks for n > lpart and will not move data if there
c     is insufficient room.
      include 'SIZE'
      include 'TOTAL'
      include 'CTIMER'

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal
      common /myparth/ i_fp_hndl, i_cr_hndl

      real    pt_timers(11), scrt_timers(11)
      common /trackingtime/ pt_timers, scrt_timers

      real    rpart(nr,n),ux(1),uy(1),uz(1)
      integer ipart(ni,n)

      parameter (lrf=4+ldim,lif=5+1)
      real               rfpts(lrf,lpart)
      common /fptspartr/ rfpts
      integer            ifpts(lif,lpart),fptsmap(lpart)
      common /fptsparti/ ifpts,fptsmap

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup

      integer icalld1
      save    icalld1
      data    icalld1 /0/

      logical partl         ! This is a dummy placeholder, used in cr()
      nl = 0                ! No logicals exchanged

      scrt_timers(4) = dnekclock()
      if (icalld1.eq.0) then
         tolin = 1.e-12
         if (wdsize.eq.4) tolin = 1.e-6
         call intpts_setup  (tolin,i_fp_hndl)
         call crystal_setup (i_cr_hndl,nekcomm,np)
         icalld1 = icalld1 + 1
      endif

      scrt_timers(9) = dnekclock()
      call particles_in_nid(fptsmap,rfpts,lrf,ifpts,lif,nfpts,rpart,nr
     $                     ,ipart,ni,n)

      scrt_timers(5) = dnekclock()
      call findpts(i_fp_hndl !  stride     !   call findpts( ihndl,
     $           , ifpts(jrc,1),lif        !   $             rcode,1,
     $           , ifpts(jpt,1),lif        !   &             proc,1,
     $           , ifpts(je0,1),lif        !   &             elid,1,
     $           , rfpts(jr ,1),lrf        !   &             rst,ndim,
     $           , rfpts(jd ,1),lrf        !   &             dist,1,
     $           , rfpts(jx ,1),lrf        !   &             pts(    1),1,
     $           , rfpts(jy ,1),lrf        !   &             pts(  n+1),1,
     $           , rfpts(jz ,1),lrf ,nfpts)    !   &             pts(2*n+1),1,n)
      scrt_timers(5) = dnekclock() - scrt_timers(5)
      pt_timers(5) = scrt_timers(5) + pt_timers(5)

      nmax = iglmax(n,1)
      if (nmax.gt.lpart) then
         if (nid.eq.0) write(6,1) nmax,lpart
    1    format('WARNING: Max number of particles:'
     $   i9,'.  Not moving because lpart =',i9,'.')
      else
         scrt_timers(6) = dnekclock()
c        copy rfpts and ifpts back into their repsected positions in rpart and ipart
         call update_findpts_info(rpart,nr,ipart,ni,n,rfpts,lrf
     $                       ,ifpts,lif,fptsmap,nfpts)
         scrt_timers(9) = dnekclock() - scrt_timers(9) - scrt_timers(5)
         pt_timers(9) = scrt_timers(9) + pt_timers(9)
c        Move particle info to the processor that owns each particle
c        using crystal router in log P time:

         jps = jai-1     ! Pointer to temporary proc id for swapping
         do i=1,n        ! Can't use jpt because it messes up particle info
            ipart(jps,i) = ipart(jpt,i)
         enddo
         call crystal_tuple_transfer(i_cr_hndl,n,lpart
     $              , ipart,ni,partl,nl,rpart,nr,jps)
c        Sort by element number - for improved local-eval performance
         call crystal_tuple_sort    (i_cr_hndl,n 
     $              , ipart,ni,partl,nl,rpart,nr,je0,1)
         pt_timers(6) = pt_timers(6) + dnekclock() - scrt_timers(6)
      endif

c     Interpolate (locally, if data is resident).
      scrt_timers(7) = dnekclock()
      call baryweights_findpts_eval(rpart,nr,ipart,ni,n)
      pt_timers(7) = pt_timers(7) + dnekclock() - scrt_timers(7)
      pt_timers(4) = pt_timers(4) + dnekclock() - scrt_timers(4)
      return
      end
c-----------------------------------------------------------------------
      subroutine update_stokes_particles(rpart,nr,ipart,ni,n)
c     Single step of Stokes particle dynamics
      include 'SIZE'
      include 'TOTAL'
      include 'CMTDATA'
      include 'CTIMER'

      common /myparth/ i_fp_hndl, i_cr_hndl
      common /myparts/ times(0:3),alpha(0:3),beta(0:3)
      real    pt_timers(11), scrt_timers(11)
      common /trackingtime/ pt_timers, scrt_timers

      real    rpart(nr,n)
      integer ipart(ni,n)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup
      jx0 = jx

      scrt_timers(8) = dnekclock()
      call get_bdf_ext_coefs(beta,alpha,times)
c     Solve for velocity at time t^n
      do j=0,ndim-1
      do i=1,n
         rpart(ju3+j,i)=rpart(ju2+j,i)
         rpart(ju2+j,i)=rpart(ju1+j,i)
         rpart(ju1+j,i)=rpart(ju0+j,i)
         rpart(jv3+j,i)=rpart(jv2+j,i)
         rpart(jv2+j,i)=rpart(jv1+j,i)
         rpart(jv1+j,i)=rpart(jv0+j,i)
         rpart(jx3+j,i)=rpart(jx2+j,i)
         rpart(jx2+j,i)=rpart(jx1+j,i)
         rpart(jx1+j,i)=rpart(jx0+j,i)
      enddo
      enddo

      do i=1,n
        s = 1.0 / rpart(jtaup,i)    ! inverse stokes number
        do j=0,ndim-1
          rhs = s*( alpha(1)*rpart(ju1+j,i)
     $            + alpha(2)*rpart(ju2+j,i)
     $            + alpha(3)*rpart(ju3+j,i)) + rpart(jf0,i)
     $        +     beta (1)*rpart(jv1+j,i)
     $        +     beta (2)*rpart(jv2+j,i)
     $        +     beta (3)*rpart(jv3+j,i)
          rpart(jv0+j,i) = rhs / (beta(0)+s) ! Implicit solve for v
          rhx = beta (1)*rpart(jx1+j,i)
     $        + beta (2)*rpart(jx2+j,i)
     $        + beta (3)*rpart(jx3+j,i) + rpart(jv0+j,i)
          rpart(jx0+j,i) = rhx / beta(0)     ! Implicit solve for x
        enddo
      enddo
c     check if all particles are inside the domain:
      call update_particle_location(nr,n,jx0,jx1,jx2,jx3,rpart)
      pt_timers(8) = pt_timers(8) + dnekclock() - scrt_timers(8)

c     Interpolate current velocity field at current position, to
c     be used in _next_ particle update step.
      call compute_primitive_vars
      call interp_u_for_adv(rpart,nr,ipart,ni,n,vx,vy,vz)
      return
      end
c-----------------------------------------------------------------------
      subroutine get_bdf_ext_coefs(beta,alpha,times)
      include 'SIZE'
      include 'TOTAL'

      real beta(0:3),alpha(0:3),times(0:3)
      real c(0:8)

      integer ilast,ncoef
      save    ilast,ncoef
      data    ilast,ncoef / -9 , 0 /

      do i=3,1,-1
         times(i)=times(i-1)
      enddo
      times(0) = time

      call rzero(beta ,4)
      call rzero(alpha,4)
      if (istep.ne.ilast) then
         ilast = istep
         ncoef = ncoef + 1
         ncoef = min(ncoef,3) ! Maximum 3rd order in time
      endif
      ncoefm1 = ncoef - 1

      call fd_weights_full(times(0),times(1),ncoefm1,0,alpha(1))
      call fd_weights_full(times(0),times(0),ncoef,1,c)
      do j=0,ncoef
         beta(j) = c(ncoef+1+j)
      enddo
      do j=1,ncoef
         beta(j) = -beta(j)  ! Change sign, for convenience
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine update_particle_location(nr,n,jx0,jx1,jx2,jx3,rpart)
      include 'SIZE'

      real rpart(nr,n)
      real  xdrange(2,3) 
      common /domainrange/ xdrange

      do i=1,n
         do j=0,ndim-1
            if (rpart(jx0+j,i).lt.xdrange(1,j+1))then
               rpart(jx0+j,i) = xdrange(2,j+1) - 
     &                          abs(xdrange(1,j+1) - rpart(jx0+j,i))
               rpart(jx1+j,i) = xdrange(2,j+1) + 
     &                          abs(xdrange(1,j+1) - rpart(jx1+j,i))
               rpart(jx2+j,i) = xdrange(2,j+1) + 
     &                          abs(xdrange(1,j+1) - rpart(jx2+j,i))
               rpart(jx3+j,i) = xdrange(2,j+1) + 
     &                          abs(xdrange(1,j+1) - rpart(jx3+j,i))
            endif
            if (rpart(jx0+j,i).gt.xdrange(2,j+1))then
               rpart(jx0+j,i) = xdrange(1,j+1) +
     &                          abs(rpart(jx0+j,i) - xdrange(2,j+1))
               rpart(jx1+j,i) = xdrange(1,j+1) -
     &                          abs(xdrange(2,j+1) - rpart(jx1+j,i))
               rpart(jx2+j,i) = xdrange(1,j+1) -
     &                          abs(xdrange(2,j+1) - rpart(jx2+j,i))
               rpart(jx3+j,i) = xdrange(1,j+1) -
     &                          abs(xdrange(2,j+1) - rpart(jx3+j,i))
            endif
         enddo
      enddo
      return
      end
c----------------------------------------------------------------------
      subroutine output_particles_newest(rpart,nr,ipart,ni,n,istep)
      include 'SIZE'
      include 'mpif.h'

      common /nekmpi/ mid,np,nekcomm,nekgroup,nekreal

      real    rpart(nr,n)
      integer ipart(ni,n)

      real x(ldim,lpart),partv(lpart)
      common /scrns/ x_tmp(ldim+2,lpart),work(ldim+2,lpart)
     $              ,v_tmp(ldim+1,lpart)
      character*128 fname
      character*15 mystring, velstring
      integer oldfile, wdata_type, newfile
      integer*8 disp
      integer*8 extent_in_file, lb,extent
      integer stride_len 
      integer prevs(0:np-1)
      integer status(MPI_STATUS_SIZE)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup
      integer icalld
      save    icalld
      data    icalld  /-1/

c     sned previous number of particles before a given mpi rank
c     so that propper striding can be done
      call MPI_Send(n, 1, MPI_INTEGER, 0, 0, nekcomm, ierr)

      stride_len = 0
      npt_total = iglsum(n,1)

c     write particle data to read into script
      if (nid.eq. 0) then
         prevs(0) = n
         do i=1,np-1
            call MPI_Recv(prevs(i),1,MPI_INTEGER,i,
     >                    0,nekcomm,status,ierr)
         enddo
      endif

      call MPI_BCAST(prevs,np, MPI_INTEGER,0,nekcomm,ierr) 

c     striding depends on the number of particles per mpi rank on
c     all of the previous mpi ranks from [0, nid-1]
      if (nid .ne. 0) then
      do i=1,nid
         stride_len = stride_len + prevs(i-1)
      enddo
      endif

c     write to file
      icalld = icalld+1
      write(mystring,'(A7,I5.5,A3)') 'partxyz', icalld, '.3D' 
      write(velstring,'(A7,I5.5,A3)') 'velsxyz', icalld, '.3D' 
      
      call MPI_FILE_OPEN(nekcomm, mystring,
     >                   MPI_MODE_CREATE + MPI_MODE_WRONLY, 
     >                   MPI_INFO_NULL, oldfile, ierr) 
      disp = 0
      call MPI_FILE_SET_VIEW(oldfile, disp, MPI_BYTE,
     >                       MPI_BYTE, "native", 
     >                       MPI_INFO_NULL, ierr) 

      call MPI_Type_vector(n,1,nr,MPI_DOUBLE_PRECISION,
     >                    wdata_type,ierr)
      call MPI_Type_commit(wdata_type,ierr)

c     write x particle location
      disp = 8*stride_len 
      call MPI_FILE_SET_VIEW(oldfile, disp, MPI_DOUBLE_PRECISION,
     >                       MPI_DOUBLE_PRECISION, "native", 
     >                       MPI_INFO_NULL, ierr) 
      call MPI_FILE_WRITE_ALL(oldfile, rpart(jx,1), 1,
     >                  wdata_type,
     >                  MPI_STATUS_IGNORE, ierr) 

c     write y particle location
      disp = 8*stride_len + 8*npt_total
      call MPI_FILE_SET_VIEW(oldfile, disp, MPI_DOUBLE_PRECISION,
     >                       MPI_DOUBLE_PRECISION, "native", 
     >                       MPI_INFO_NULL, ierr) 
      call MPI_FILE_WRITE_ALL(oldfile, rpart(jy,1), 1,
     >                  wdata_type,
     >                  MPI_STATUS_IGNORE, ierr) 

c     write z particle location
      disp = 8*stride_len + 8*npt_total*2
      call MPI_FILE_SET_VIEW(oldfile, disp, MPI_DOUBLE_PRECISION,
     >                       MPI_DOUBLE_PRECISION, "native", 
     >                       MPI_INFO_NULL, ierr) 
      call MPI_FILE_WRITE_ALL(oldfile, rpart(jz,1), 1,
     >                  wdata_type,
     >                  MPI_STATUS_IGNORE, ierr) 
c     close file
      call MPI_FILE_CLOSE(oldfile, ierr) 

c     velocities --------
      call MPI_FILE_OPEN(nekcomm, velstring,
     >                   MPI_MODE_CREATE + MPI_MODE_WRONLY, 
     >                   MPI_INFO_NULL, newfile, ierr) 
      
c     write x particle location
      do i=1,n
         if (ipart(jai,i) .eq. 2) then
            open(unit=74,file='velhistory')
            write(74, "(I6,F9.5,F9.5,F9.5)") istep, 
     >                  rpart(jv0,i), rpart(jv0+1,i), rpart(jv0+2,i)
            write(*,*) 'vel: ', rpart(jv0,i)
         endif
      enddo

c     close file
      call MPI_FILE_CLOSE(newfile, ierr) 

      return
      end
c-----------------------------------------------------------------------
      subroutine particles_in_nid(fptsmap,rfpts,nrf,ifpts,nif,nfpts
     &                            ,rpart,nr,ipart,ni,n)
      include 'SIZE'

      real    rpart(nr,n)
      integer ipart(ni,n)

      real    rfpts(nrf,*)
      integer ifpts(nif,*),fptsmap(*)

      real   xerange(2,3,lelt)
      common /elementrange/ xerange

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup

      nfpts = 0
      do ip = 1,n
         xloc = rpart(jx,ip)
         yloc = rpart(jy,ip)
         zloc = rpart(jz,ip)
         itest = 0
         do ie=1,nelt
            if (xloc.ge.xerange(1,1,ie).and.xloc.le.xerange(2,1,ie))then
            if (yloc.ge.xerange(1,2,ie).and.yloc.le.xerange(2,2,ie))then
            if (zloc.ge.xerange(1,3,ie).and.zloc.le.xerange(2,3,ie))then
                ipart(je0 ,ip) = ie-1
                ipart(jrc ,ip) = 0
                ipart(jpt ,ip) = nid
                rpart(jd  ,ip) = 1.0 
                rloc = -1.0 + 2.0*(xloc - xerange(1,1,ie))/
     $                 (xerange(2,1,ie)-xerange(1,1,ie))
                sloc = -1.0 + 2.0*(yloc - xerange(1,2,ie))/
     $                 (xerange(2,2,ie)-xerange(1,2,ie))
                tloc = -1.0 + 2.0*(zloc - xerange(1,3,ie))/
     $                 (xerange(2,3,ie)-xerange(1,3,ie))
                rpart(jr  ,ip) = rloc
                rpart(jr+1,ip) = sloc
                rpart(jr+2,ip) = tloc
                itest = 1
                goto 123
            endif
            endif
            endif
         enddo
         if (itest.eq.0)then
            nfpts = nfpts + 1
            fptsmap(nfpts) = ip
            call copy (rfpts(1,nfpts),rpart(1,ip),nrf) 
            call icopy(ifpts(1,nfpts),ipart(1,ip),nif) 
            if(nfpts.gt.lpart)then
               write(6,*)'Too many points crossing over ',
     $                      nfpts,lpart,nid
               call exitt
            endif
         endif
123      continue
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine update_findpts_info(rpart,nr,ipart,ni,n,rfpts,nrf
     $                         ,ifpts,nif,fptsmap,nfpts)
      include 'SIZE'
      real    rpart(nr,n)
      integer ipart(ni,n)

      real    rfpts(nrf,nfpts)
      integer ifpts(nif,nfpts),fptsmap(nfpts)
      do ifp = 1,nfpts
         call copy(rpart(1,fptsmap(ifp)),rfpts(1,ifp),nrf)
         call icopy(ipart(1,fptsmap(ifp)),ifpts(1,ifp),nif)
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine baryweights
      include 'SIZE' 
      include 'INPUT' 
c
c     calculates the barycentric lagrange weights
c
      common /BARYPARAMS/ xgll, ygll, zgll, wxgll, wygll, wzgll
      real xgll(lx1), ygll(ly1), zgll(lz1),
     >     wxgll(lx1), wygll(ly1), wzgll(lz1)


      one = 1.0
      pi  = 4.0*atan(one)

c     get gll points in all directions
      call zwgll(xgll,wxgll,lx1)
      call zwgll(ygll,wygll,ly1)
      call rone(zgll,lz1)
      if(if3d) call zwgll(zgll,wzgll,lz1)
c     set all weights to ones first
      call rone(wxgll,lx1)
      call rone(wygll,ly1)
      call rone(wzgll,lz1)
c     calc x bary weights
      do j=1,lx1
         do k=1,lx1
            if (j .NE. k) then
               wxgll(j) = wxgll(j)/(xgll(j) - xgll(k))
            endif
         enddo
      enddo
c     calc y bary weights
      do j=1,ly1
         do k=1,ly1
            if (j .NE. k) then
               wygll(j) = wygll(j)/(ygll(j) - ygll(k))
            endif
         enddo
      enddo
c     calc z bary weights
      do j=1,lz1
         do k=1,lz1
            if (j .NE. k) then
               wzgll(j) = wzgll(j)/(zgll(j) - zgll(k))
            endif
         enddo
      enddo
      return 
      end
c-----------------------------------------------------------------------
      subroutine baryweights_findpts_eval(rpart,nr,ipart,ni,n)
      include 'SIZE'
      include 'INPUT'
      include 'SOLN'
      real    rpart(nr,n)
      integer ipart(ni,n)

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup

      common /BARRYREP/ rep, bot
      real              rep(lx1,ly1,lz1), bot
      nxyz = nx1*ny1*nz1
      if (if3d) then
        do i=1,n
           call init_baryinterp(rpart(jr,i),rpart(jr+1,i),rpart(jr+2,i))
           ie  =  ipart(je0,i) + 1
           call baryinterp_new(vx(1,1,1,ie),rpart(ju0,i))
           call baryinterp_new(vy(1,1,1,ie),rpart(ju0+1,i))
           call baryinterp_new(vz(1,1,1,ie),rpart(ju0+2,i))
        enddo
      else
        do i=1,n
           call init_baryinterp(rpart(jr,i),rpart(jr+1,i),1.0)
           ie  =  ipart(je0,i) + 1
           call baryinterp_new(vx(1,1,1,ie),rpart(ju0,i))
           call baryinterp_new(vy(1,1,1,ie),rpart(ju0+1,i))
        enddo
      endif
      return
      end
c-----------------------------------------------------------------------
      subroutine init_baryinterp(x,y,z)
      include 'SIZE'
      common /BARYPARAMS/ xgll, ygll, zgll, wxgll, wygll, wzgll
      real xgll(lx1), ygll(ly1), zgll(lz1),
     >     wxgll(lx1), wygll(ly1), wzgll(lz1)
      common /BARRYREP/ rep, bot
      real              rep(lx1,ly1,lz1), bot

      real x, y, z, repy, repz,repx
      real bwgtx(lx1),bwgty(ly1),bwgtz(lz1)
c     main loop, but notice bwgtz, bwgtx, bwgty could be NaN if
c     interpolated point is on a grid location. Need to fix, but
c     is currently very robust
      bot= 0.00
      do k=1,nz1
         bwgtz(k) = wzgll(k)/(z-zgll(k))
      enddo
      do i=1,nx1
         bwgtx(i) = wxgll(i)/(x-xgll(i))
      enddo 
      do j=1,ny1
         bwgty(j) = wygll(j)/(y-ygll(j))
      enddo
      do k=1,nz1
      do j=1,ny1
         repdum = bwgty(j)*bwgtz(k)
      do i=1,nx1
         rep(i,j,k) =  repdum* bwgtx(i)
         bot        =  bot + rep(i,j,k)
      enddo
      enddo
      enddo 
      return
      end
c-----------------------------------------------------------------------
      subroutine baryinterp_new(field,pofx)
      include 'SIZE'

      common /BARRYREP/ rep, bot
      real              rep(lx1,ly1,lz1), bot
      real field(1),pofx,top

      top = 0.00
      nxyz = nx1*ny1*nz1
      do i=1,nxyz
         top =  top + rep(i,1,1)*field(i)
      enddo
      pofx = top/bot
      return
      end
c-----------------------------------------------------------------------
      FUNCTION ran2(idum)
      INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV 
      REAL ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     $        IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,
     $        IR2=3791,NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
c Long period (> 2 ! 1018 ) random number generator of Lâ€™Ecuyer with 
c Bays-Durham shuffle and added safeguards. Returns a uniform random deviate 
c between 0.0 and 1.0 (exclusive of the endpoint values). 
c Call with idum a negative integer to initialize; thereafter, do not alter 
c idum between successive deviates in a sequence. RNMX should approximate the 
c largest floating value that is less than 1.
      INTEGER idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/, iv/NTAB*0/, iy/0/
      if (idum.le.0) then 
         idum1=max(-idum,1) 
         idum2=idum1
         do j=NTAB+8,1,-1
            k=idum1/IQ1
            idum1=IA1*(idum1-k*IQ1)-k*IR1 
            if (idum1.lt.0) idum1=idum1+IM1 
            if (j.le.NTAB) iv(j)=idum1
         enddo
         iy=iv(1) 
      endif
      k=idum1/IQ1 
      idum1=IA1*(idum1-k*IQ1)-k*IR1
      if (idum1.lt.0) idum1=idum1+IM1 
      k=idum2/IQ2 
      idum2=IA2*(idum2-k*IQ2)-k*IR2 
      if (idum2.lt.0) idum2=idum2+IM2 
      j=1+iy/NDIV
      iy=iv(j)-idum2
      iv(j)=idum1 
      if(iy.lt.1)iy=iy+IMM1 
      ran2=min(AM*iy,RNMX)
      return
      END
c-----------------------------------------------------------------------
c     subtroutines not currently used, but useful for instruction
c----------------------------------------------------------------------
      subroutine output_particles_new(rpart,nr,ipart,ni,n)
      include 'SIZE'

      real    rpart(nr,n)
      integer ipart(ni,n)

      real x(ldim,lpart),partv(lpart)
      common /scrns/ x_tmp(ldim+2,lpart),work(ldim+2,lpart)
     $              ,v_tmp(ldim+1,lpart)
      character*128 fname

      common /ptpointers/ jrc,jpt,je0,jps,jai,nai,jr,jd,jx,jy,jz,jx1
     $            ,jx2,jx3,jv0,jv1,jv2,jv3,ju0,ju1,ju2,ju3,jf0,jar,nar
     $            ,jtaup
      integer icalld
      save    icalld
      data    icalld  /-1/

      icalld = icalld+1
      if (nid.eq.0) then
        write(fname,1) icalld
 1      format('part',i5.5,'.3D')
        open(unit=72,file=fname)

        write(fname,2) icalld
 2      format('vel',i5.5,'.3D')
        open(unit=73,file=fname)
      endif

      npt_total = iglsum(n,1)
      npass = npt_total / lpart
      if (npt_total.gt.npass*lpart) npass = npass+1
      ilast = 0
      do ipass=1,npass
        mpart = min(lpart,npt_total-ilast)
        i0    = ilast
        i1    = i0 + mpart
        ilast = i1

        call rzero(x_tmp,(ldim+2)*lpart)
        call rzero(v_tmp,(ldim+1)*lpart)
        do ii=1,n ! loop over all particles
          if (i0.lt.ipart(jai,ii).and.ipart(jai,ii).le.i1) then
            i = ipart(jai,ii)-i0
            call copy(x_tmp(1,i),rpart(jx,ii),ldim)  ! Coordinates
            x_tmp(ldim+1,i) = ipart(jpt,ii) ! MPI rank
            x_tmp(ldim+2,i) = ipart(jai,ii) ! Part id 
            call copy(v_tmp(1,i),rpart(jv0,ii),ldim)  ! Velocity 
            v_tmp(ldim+1,i) = ipart(jai,ii) ! Part id 
          endif
        enddo
        call gop(x_tmp,work,'+  ',(ldim+2)*lpart)
        call gop(v_tmp,work,'+  ',(ldim+1)*lpart)
        if (nio.eq.0) write(72,3)((x_tmp(k,i),k=1,ldim+2),i=1,mpart)
        if (nio.eq.0) write(73,4)((v_tmp(k,i),k=1,ldim+1),i=1,mpart)
 3      format(1p5e17.9)
 4      format(1p4e17.9)
      enddo

      if (nio.eq.0) close(72)
      if (nio.eq.0) close(73)
      return
      end
c-----------------------------------------------------------------------
      subroutine baryinterp(x,y,z,nfields,fields,p)
c
c     not currently used, but here for illustration; replaced by
c     baryinterp_new and init_baryinterp
c
      include 'SIZE'
      
      integer nfields
      common /BARYPARAMS/ xgll, ygll, zgll, wxgll, wygll, wzgll
      real xgll(lx1), ygll(ly1), zgll(lz1),
     >     wxgll(lx1), wygll(ly1), wzgll(lz1)
      real      top(nfields), bot(nfields), p(nfields)
      real x, y, z, rep
      real fields(nx1,ny1,nz1,nfields)

      call rzero(top,nfields)
      call rzero(bot,nfields)
c     main loop, but notice repx, repy, repz could be NaN if
c     interpolated point is on a grid location. Need to fix, but
c     is currently very robust
      do k=1,lz1
         repz = wzgll(k)/(z-zgll(k))
         do j=1,ly1
            repy = repz*wygll(j)/(y-ygll(j))
            do i=1,lx1
               repx = repy*wxgll(i)/(x-xgll(i))
               do l=1,nfields
                  top(l) = top(l) + repx*fields(i,j,k,l)
                  bot(l) = bot(l) + repx
               enddo
            enddo
         enddo
      enddo

      do l=1,nfields 
         p(l) = top(l)/bot(l)
      enddo
      return 
      end
c----------------------------------------------------------------------

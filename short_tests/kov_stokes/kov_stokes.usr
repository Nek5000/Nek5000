c-----------------------------------------------------------------------
c
c Kovasznay flow, an analytical two-dimensional steady solution to the
c incompressible Navier-Stokes equations.  
c
c 
c This case tests user-explicit treatment of the nonlinear terms.
c 
c Specifically, it allows the user to set a rhs term of the form:
c 
c (1)    rhs = - [ (U.grad V) + (V.grad U) ]
c 
c where U and V can be vector fields of the user's choice.
c 
c Here, we test the functionality of this feature by considering the 
c Kovazsnay problem with the standard Nek5000 nonlinear treatment 
c turned OFF, which is accomplished by setting IFNAV to F in the .rea 
c file.   The net result is an unsteady Stokes problem.
c 
c We then augment the Stokes problem with a time-dependent forcing
c by setting ffx and ffy in userf() in the .usr file.  The pointwise
c values of ffx and ffy are taken from an array that is computed 
c once per timestep in userchk.   These nonlinear contributions
c are generated by the following ad hoc test routine:
c 
c       call set_ns_rhs   !  Test ad-hoc nonlinear function evaluation
c 
c which in turn makes the call to effect (1):
c 
c       call ugv_vgu(w1,w2,w3,vx,vy,vz,vx,vy,vz,1)
c 
c This case gives a final error of 1.e-8, a strong indicator that things
c are indeed functioning correctly.   Turning the functionality off via
c "call opzero(w1,w2,w3)" leads to and order unity error.
c 
c 
c    Note that the timing of the call to userhk is precisely correct
c in the following sense.  Userchk is called at the _end_ of the nth 
c timestep, when the time is set to  time=n*dt (for dt constant, say).
c 
c At this point, all arrays contain values associated with time t=n*dt.
c (On the first userchk call, just after setting initial conditions,
c we have time t=0.)
c 
c Thus, in the example described above the arrays w1() and w2() are
c filled with quantites from time-level n.
c 
c On the _next_ step, level n+1, the ffx and ffy arrays are filled by
c userf, which is expecting function values from time level n.   In fact,
c when userf() is called, the "time" variable is automatically set back
c to its value at Step n, in case the user is providing a function with
c an explicit dependence on time.   All values generated in userf() are
c then stored for the given time level, so that multiple preceding levels
c can be used to generate the proper kth-order extrapolation in time.
c 
c
c-----------------------------------------------------------------------
c
c  User specified routines 
c     - boundary conditions
c     - initial conditions
c     - variable properties
c     - forcing function for fluid (f)
c     - forcing function for passive scalar (q)
c     - general purpose routine for checking errors etc.
c
c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /c_my_ns/ w1(lx1,ly1,lz1,lelt)
     $                ,w2(lx1,ly1,lz1,lelt),w3(lx1,ly1,lz1,lelt)

      integer e,f,eg

      e = gllel(eg)

      ffx = w1(ix,iy,iz,e) !  Note: this is an acceleration term, 
      ffy = w2(ix,iy,iz,e) !  NOT a force!  Thus, ffx will be
      ffz = w3(ix,iy,iz,e) !  subsequently multiplied by rho(x,t).

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      qvol   = 0.0
      source = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
c
      common /cprint/ ifprint
      logical         ifprint
      common /ctmp1e/ uxe (lx1,ly1,lz1,lelv), uye (lx1,ly1,lz1,lelv)
      common /scruz/  erru(lx1,ly1,lz1,lelv), errv(lx1,ly1,lz1,lelv)
     $               ,errw(lx1,ly1,lz1,lelv)
c
      integer icalld
      save    icalld
      data    icalld /0/

      real xp(ldim,10)

      ntot=nx1*ny1*nz1*nelv

      call set_ns_rhs   !  Test ad-hoc nonlinear function evaluation


      a1=1.0
      if (icalld.eq.0) then
         icalld=1
c
         vis=  param(2)
         if (vis.lt.0) vis = 1./abs(vis)
         one  =1.0
         twopi=8.0*atan(one)
         reyn=1.0/vis
         ccc = 0.25*reyn**2 + twopi*twopi
         rlam=reyn/2.0 - sqrt( ccc )
c
c        Compute the exact solution
c
         do 100 i=1,ntot
            x=xm1(i,1,1,1)
            y=ym1(i,1,1,1)
            uxe(i,1,1,1) =  1.0  - exp(rlam*x)*cos(twopi*y)
            uye(i,1,1,1) =  rlam * exp(rlam*x)*sin(twopi*y)/twopi
            errw(i,1,1,1) = 0.0
  100    continue
  101    format(3g14.7)
      endif
c     if (ifprint) then
c
c       Compute the error
c
        errmu=vx(1,1,1,1)-uxe(1,1,1,1)
        errmv=vy(1,1,1,1)-uye(1,1,1,1)
        do 200 i=1,ntot
           erru(i,1,1,1)=vx(i,1,1,1)-uxe(i,1,1,1)
           errv(i,1,1,1)=vy(i,1,1,1)-uye(i,1,1,1)
           if(erru(i,1,1,1).gt.errmu) then
              errmu=erru(i,1,1,1)
              iemu=i
           endif
           if(errv(i,1,1,1).gt.errmv) then
              errmv=errv(i,1,1,1)
              iemv=i
           endif
  200   continue
        errmu=glamax(erru,ntot)
        errmv=glamax(errv,ntot)
c
        ifield=1
        call normvc (h1,semi,hl2,hlinf,erru,errv,errw)
        call normvc (h1E,semiE,hl2E,hlinfE,uxe,uye,errw)
        hl2_wt = hl2/hl2e
c
        npoly = lx1-1
        if (nid.eq.0) write(6,301) istep,npoly,h1,semi,hl2,hlinf,time
  301   format(i6,i3,1p5e13.5,' err')
c     endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      vis    = param(2)
      one    = 1.0
      twopi  = 8.0*atan(one)
      reyn   = 1.0/vis
      ccc    = 0.25*reyn**2 + twopi*twopi
      rlam   = reyn/2.0 - sqrt( ccc )
      ux     = 1.0  - exp(rlam*x)*cos(twopi*y)
      uy     = rlam * exp(rlam*x)*sin(twopi*y)/twopi
      uz     = 0.0

      temp=0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      vis    = param(2)
      one    = 1.
      twopi  = 8.0*atan(one)
      reyn   = 1.0/vis
      ccc    = 0.25*reyn**2 + twopi*twopi
      rlam   = reyn/2.0 - sqrt( ccc )
      ux     = 1.0  - exp(rlam*x)*cos(twopi*y)
      uy     = rlam * exp(rlam*x)*sin(twopi*y)/twopi
      uz     = 0.0

      temp=0

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'


      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      return
      end
c-----------------------------------------------------------------------
      subroutine op_c2f_e(uf1,uf2,uf3,u1,u2,u3)

c     map coarse GLL u_i to fine mesh uf_i  (GL)

      include 'SIZE'
      include 'TOTAL'

      real uf1(1),uf2(1),uf3(1),u1(1),u2(1),u3(1)

      call intp_rstd(uf1,u1,nx1,nxd,if3d,0) ! 0 --> forward
      call intp_rstd(uf2,u2,nx1,nxd,if3d,0) ! 0 --> forward
      if (if3d) call intp_rstd(uf3,u3,nx1,nxd,if3d,0) ! 0 --> forward

      return
      end
c-----------------------------------------------------------------------
      subroutine op_bi_f2c_e(u1,u2,u3,uf1,uf2,uf3,e)

c     project fine uf (GL) back to coarse u on GLL points

      include 'SIZE'
      include 'TOTAL'

      real u1(1),u2(1),u3(1),uf1(1),uf2(1),uf3(1)
      integer e

      call intp_rstd(u1,uf1,nx1,nxd,if3d,1) ! Project back to coarse
      call intp_rstd(u2,uf2,nx1,nxd,if3d,1) ! Project back to coarse
      if (if3d) call intp_rstd(u3,uf3,nx1,nxd,if3d,1) ! Project back to coarse

      nxyz = nx1*ny1*nz1           !                 -1
      if (if3d) then               ! Apply (local!) B    to get back
         do i=1,nxyz               ! to physical space.
            bi = 1./bm1(i,1,1,e)   !
            u1(i) = bi*u1(i)
            u2(i) = bi*u2(i)
            u3(i) = bi*u3(i)
         enddo
      else
         do i=1,nxyz
            bi = 1./bm1(i,1,1,e)
            u1(i) = bi*u1(i)
            u2(i) = bi*u2(i)
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine convpe(cu,v1,v2,v3,uf,ur,us,ut,e)

c     cu = cu + B*V.grad u ! dealiased on fine GL mesh
      
      include 'SIZE'
      include 'TOTAL'

      real cu(1),v1(1),v2(1),v3(1),uf(1),ur(1),us(1),ut(1)
      integer e

      nxyzd = nxd*nyd*nzd

      call grad_rst(ur,us,ut,uf,nxd,if3d)

      if (if3d) then   ! mass matrix included, per DFM (4.8.5)
         do i=1,nxyzd
            tr1   = rx(i,1,e)*v1(i)+rx(i,2,e)*v2(i)+rx(i,3,e)*v3(i)
            tr2   = rx(i,4,e)*v1(i)+rx(i,5,e)*v2(i)+rx(i,6,e)*v3(i)
            tr3   = rx(i,7,e)*v1(i)+rx(i,8,e)*v2(i)+rx(i,9,e)*v3(i)
            cu(i) = cu(i) + tr1*ur(i)+tr2*us(i)+tr3*ut(i)
         enddo
      else
         do i=1,nxyzd
            tr1   = rx(i,1,e)*v1(i)+rx(i,2,e)*v2(i)
            tr2   = rx(i,3,e)*v1(i)+rx(i,4,e)*v2(i)
            cu(i) = cu(i) + tr1*ur(i)+tr2*us(i)
         enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine ugv_vgu_e(w1,w2,w3,u1,u2,u3,v1,v2,v3,e
     $                    ,wf,vf,uf,ur,us,ut)
c
c     Compute W = U.grad V + V.grad U
c
c     using dealiased form:  J^T Bf *JC .grad Ju w/ correct Jacobians
c

      include 'SIZE'
      include 'TOTAL'

      real w1(1),w2(1),w3(1),u1(1),u2(1),u3(1),v1(1),v2(1),v3(1)
      integer e

      parameter (ld=lxd*lyd*lzd)
      real wf(ld,3),vf(ld,3),uf(ld,3),ur(ld),us(ld),ut(ld)

      call op_c2f_e(uf(1,1),uf(1,2),uf(1,3),u1,u2,u3) ! Uf = J*U
      call op_c2f_e(vf(1,1),vf(1,2),vf(1,3),v1,v2,v3) ! Vf = J*V


      call rzero(wf,3*ld)    ! W = 0

      do i=1,ndim            ! W = W + U.grad V
         call convpe(wf(1,i),uf(1,1),uf(1,2),uf(1,3),vf(1,i),ur,us,ut,e)
      enddo

      do i=1,ndim            ! W = W + V.grad U
         call convpe(wf(1,i),vf(1,1),vf(1,2),vf(1,3),uf(1,i),ur,us,ut,e)
      enddo

c     Note: Binv needed below because userf() expects the rhs this way
                                                           !      -1  T
      call op_bi_f2c_e(w1,w2,w3,wf(1,1),wf(1,2),wf(1,3),e) ! W = B   J  W
                                                           !      e      f
      return
      end
c-----------------------------------------------------------------------
      subroutine ugv_vgu(w1,w2,w3,u1,u2,u3,v1,v2,v3,ifld)

c     Compute W = U.grad V + V.grad U
c
c     using dealiased form:  J^T Bf *JC .grad Ju w/ correct Jacobians


      include 'SIZE'
      include 'TOTAL'

      parameter (ln=lx1*ly1*lz1,ld=lxd*lyd*lzd)

      real w1(ln,1),w2(ln,1),w3(ln,1)
     $    ,u1(ln,1),u2(ln,1),u3(ln,1)
     $    ,v1(ln,1),v2(ln,1),v3(ln,1)

      common /scruz/ ur(ld),us(ld),ut(ld),wf(ld,3),vf(ld,3),uf(ld,3)

      integer e

      call set_dealias_rx  ! Make certain metrics are up-to-date

      do e=1,nelfld(ifld)
         call ugv_vgu_e( w1(1,e),w2(1,e),w3(1,e)
     $                 , u1(1,e),u2(1,e),u3(1,e)
     $                 , v1(1,e),v2(1,e),v3(1,e) , e
     $                 , wf,vf,uf,ur,us,ut)
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine set_ns_rhs
      include 'SIZE'
      include 'TOTAL'

      common /c_my_ns/ w1(lx1,ly1,lz1,lelt)
     $                ,w2(lx1,ly1,lz1,lelt),w3(lx1,ly1,lz1,lelt)

c     Test user-defined Navier-Stokes terms: 0.5*(u.grad u + u.grad u)

      call ugv_vgu(w1,w2,w3,vx,vy,vz,vx,vy,vz,1)

      half = -.5
      call opcmult(w1,w2,w3,half)  ! Subtract from RHS --> -0.5

c      call opzero (w1,w2,w3)       ! Uncomment this to test null function

      return
      end
c-----------------------------------------------------------------------
